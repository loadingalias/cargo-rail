//! Plan execution engine
//!
//! Executes Plans generated by commands, providing deterministic, reviewable operations.
//!
//! # Architecture
//!
//! Commands generate Plans → PlanExecutor executes them → Results
//!
//! This enables:
//! - Dry-run mode (show plan without executing)
//! - Idempotent operations (same plan = same result)
//! - Auditability (plans are JSON-serializable)

use crate::cargo::metadata::WorkspaceMetadata;
use crate::cargo::transform::{CargoTransform, TransformContext};
use crate::core::config::{SecurityConfig, SplitMode};
use crate::core::conflict::ConflictStrategy;
use crate::core::context::WorkspaceContext;
use crate::core::error::{RailError, RailResult, ResultExt};
use crate::core::plan::{Operation, Plan};
use crate::core::split::{SplitConfig, Splitter};
use crate::core::sync::{SyncConfig, SyncDirection, SyncEngine};
use crate::core::vcs::SystemGit;
use std::fs;
use std::path::{Path, PathBuf};
use std::sync::Arc;

/// Executes plans in a workspace context
///
/// Provides a single execution path for all cargo-rail operations.
/// Commands build Plans, then PlanExecutor executes them deterministically.
pub struct PlanExecutor<'a> {
  /// Workspace context (metadata, graph, config)
  context: &'a WorkspaceContext,
}

impl<'a> PlanExecutor<'a> {
  /// Create a new executor with workspace context
  pub fn new(context: &'a WorkspaceContext) -> Self {
    Self { context }
  }

  /// Execute a plan
  ///
  /// Executes all operations in order. If any operation fails, execution stops
  /// and returns the error.
  pub fn execute(&self, plan: &Plan) -> RailResult<()> {
    for (idx, operation) in plan.operations.iter().enumerate() {
      self
        .execute_operation(operation)
        .with_context(|| format!("Failed to execute operation {} of {}", idx + 1, plan.operations.len()))?;
    }

    Ok(())
  }

  /// Execute a single operation
  fn execute_operation(&self, operation: &Operation) -> RailResult<()> {
    match operation {
      Operation::InitRepo { path } => self.execute_init_repo(path),
      Operation::Clone { url, path } => self.execute_clone(url, path),
      Operation::CreateCommit { message, files } => self.execute_create_commit(message, files),
      Operation::Push { remote, branch, force } => self.execute_push(remote, branch, *force),
      Operation::Pull { remote, branch } => self.execute_pull(remote, branch),
      Operation::Transform { path, transform_type } => self.execute_transform(path, transform_type),
      Operation::Copy { from, to } => self.execute_copy(from, to),
      Operation::CreateBranch { name, from } => self.execute_create_branch(name, from),
      Operation::Checkout { branch } => self.execute_checkout(branch),
      Operation::Merge { from, into, strategy } => self.execute_merge(from, into, strategy),
      Operation::UpdateNotes {
        notes_ref,
        commit,
        note_content,
      } => self.execute_update_notes(notes_ref, commit, note_content),
      Operation::CreatePrBranch { name, base, message } => self.execute_create_pr_branch(name, base, message),
      Operation::ExecuteSplit {
        crate_name,
        crate_paths,
        mode,
        target_repo_path,
        branch,
        remote_url,
      } => self.execute_split(crate_name, crate_paths, mode, target_repo_path, branch, remote_url),
      Operation::ExecuteSync {
        crate_name,
        crate_paths,
        mode,
        target_repo_path,
        branch,
        remote_url,
        direction,
        conflict_strategy,
      } => self.execute_sync(
        crate_name,
        crate_paths,
        mode,
        target_repo_path,
        branch,
        remote_url,
        direction,
        conflict_strategy,
      ),
    }
  }

  /// Initialize a git repository
  fn execute_init_repo(&self, path: &str) -> RailResult<()> {
    let repo_path = Path::new(path);

    // Create directory if it doesn't exist
    fs::create_dir_all(repo_path).with_context(|| format!("Failed to create directory: {}", repo_path.display()))?;

    // Run git init
    let output = std::process::Command::new("git")
      .arg("init")
      .arg(repo_path)
      .output()
      .with_context(|| format!("Failed to initialize git repository at {}", repo_path.display()))?;

    if !output.status.success() {
      return Err(RailError::message(format!(
        "git init failed: {}",
        String::from_utf8_lossy(&output.stderr)
      )));
    }

    Ok(())
  }

  /// Clone a repository
  fn execute_clone(&self, url: &str, path: &str) -> RailResult<()> {
    let dest_path = Path::new(path);

    // Create parent directory if needed
    if let Some(parent) = dest_path.parent() {
      fs::create_dir_all(parent).with_context(|| format!("Failed to create parent directory: {}", parent.display()))?;
    }

    // Use git command to clone
    let output = std::process::Command::new("git")
      .arg("clone")
      .arg(url)
      .arg(path)
      .output()
      .with_context(|| format!("Failed to clone repository from {}", url))?;

    if !output.status.success() {
      return Err(RailError::message(format!(
        "git clone failed: {}",
        String::from_utf8_lossy(&output.stderr)
      )));
    }

    Ok(())
  }

  /// Create a commit
  fn execute_create_commit(&self, message: &str, files: &[String]) -> RailResult<()> {
    // Stage files
    for file in files {
      let output = std::process::Command::new("git")
        .current_dir(&self.context.root)
        .arg("add")
        .arg(file)
        .output()
        .with_context(|| format!("Failed to stage file: {}", file))?;

      if !output.status.success() {
        return Err(RailError::message(format!(
          "git add failed: {}",
          String::from_utf8_lossy(&output.stderr)
        )));
      }
    }

    // Create commit
    let output = std::process::Command::new("git")
      .current_dir(&self.context.root)
      .args(["commit", "-m", message])
      .output()
      .context("Failed to create commit")?;

    if !output.status.success() {
      return Err(RailError::message(format!(
        "git commit failed: {}",
        String::from_utf8_lossy(&output.stderr)
      )));
    }

    Ok(())
  }

  /// Push to remote
  fn execute_push(&self, remote: &str, branch: &str, force: bool) -> RailResult<()> {
    let mut args = vec!["push", remote, branch];
    if force {
      args.push("--force");
    }

    let output = std::process::Command::new("git")
      .current_dir(&self.context.root)
      .args(&args)
      .output()
      .with_context(|| format!("Failed to push to {}/{}", remote, branch))?;

    if !output.status.success() {
      return Err(RailError::message(format!(
        "git push failed: {}",
        String::from_utf8_lossy(&output.stderr)
      )));
    }

    Ok(())
  }

  /// Pull from remote
  fn execute_pull(&self, remote: &str, branch: &str) -> RailResult<()> {
    let output = std::process::Command::new("git")
      .current_dir(&self.context.root)
      .args(["pull", remote, branch])
      .output()
      .with_context(|| format!("Failed to pull from {}/{}", remote, branch))?;

    if !output.status.success() {
      return Err(RailError::message(format!(
        "git pull failed: {}",
        String::from_utf8_lossy(&output.stderr)
      )));
    }

    Ok(())
  }

  /// Transform a file (e.g., Cargo.toml flattening)
  fn execute_transform(&self, path: &str, transform_type: &str) -> RailResult<()> {
    let file_path = Path::new(path);

    // Verify file exists
    if !file_path.exists() {
      return Err(RailError::message(format!(
        "Transform target does not exist: {}",
        file_path.display()
      )));
    }

    // Read the file content
    let content = fs::read_to_string(file_path)
      .with_context(|| format!("Failed to read file for transform: {}", file_path.display()))?;

    // Load workspace metadata and create transformer
    let metadata = WorkspaceMetadata::load(&self.context.root)?;
    let transformer = CargoTransform::new(metadata);

    // Determine crate name from context or path
    let crate_name = self
      .context
      .metadata
      .list_crates()
      .iter()
      .find(|pkg| {
        if let (Some(pkg_dir), Some(file_dir)) = (pkg.manifest_path.parent(), file_path.parent()) {
          file_dir.starts_with(pkg_dir)
        } else {
          false
        }
      })
      .map(|pkg| pkg.name.to_string())
      .unwrap_or_else(|| "unknown".to_string());

    let transform_context = TransformContext {
      crate_name,
      workspace_root: self.context.root.clone(),
    };

    // Apply the appropriate transformation
    let transformed = match transform_type {
      "workspace_to_concrete" | "path_to_version" | "to_split" => {
        transformer.transform_to_split(&content, &transform_context)?
      }
      "concrete_to_workspace" | "version_to_path" | "to_mono" => {
        transformer.transform_to_mono(&content, &transform_context)?
      }
      _ => {
        return Err(RailError::message(format!(
          "Unknown transform type: {}",
          transform_type
        )));
      }
    };

    // Write the transformed content back
    fs::write(file_path, transformed)
      .with_context(|| format!("Failed to write transformed file: {}", file_path.display()))?;

    Ok(())
  }

  /// Copy file or directory
  fn execute_copy(&self, from: &str, to: &str) -> RailResult<()> {
    let from_path = Path::new(from);
    let to_path = Path::new(to);

    // Create parent directory for destination
    if let Some(parent) = to_path.parent() {
      fs::create_dir_all(parent).with_context(|| format!("Failed to create directory: {}", parent.display()))?;
    }

    if from_path.is_dir() {
      // Copy directory recursively
      copy_dir_recursive(from_path, to_path)?;
    } else {
      // Copy single file
      fs::copy(from_path, to_path)
        .with_context(|| format!("Failed to copy {} to {}", from_path.display(), to_path.display()))?;
    }

    Ok(())
  }

  /// Create a branch
  fn execute_create_branch(&self, name: &str, from: &str) -> RailResult<()> {
    let output = std::process::Command::new("git")
      .current_dir(&self.context.root)
      .args(["branch", name, from])
      .output()
      .with_context(|| format!("Failed to create branch {} from {}", name, from))?;

    if !output.status.success() {
      return Err(RailError::message(format!(
        "git branch failed: {}",
        String::from_utf8_lossy(&output.stderr)
      )));
    }

    Ok(())
  }

  /// Checkout a branch
  fn execute_checkout(&self, branch: &str) -> RailResult<()> {
    let git = SystemGit::open(&self.context.root)?;
    git.checkout_branch(branch)?;
    Ok(())
  }

  /// Merge branches
  fn execute_merge(&self, from: &str, into: &str, strategy: &str) -> RailResult<()> {
    let git = SystemGit::open(&self.context.root)?;

    // Checkout target branch
    git.checkout_branch(into)?;

    // Merge source branch
    let mut args = vec!["merge", from];
    if !strategy.is_empty() && strategy != "default" {
      args.extend(vec!["-s", strategy]);
    }

    let output = std::process::Command::new("git")
      .current_dir(&self.context.root)
      .args(&args)
      .output()
      .with_context(|| format!("Failed to merge {} into {}", from, into))?;

    if !output.status.success() {
      return Err(RailError::message(format!(
        "git merge failed: {}",
        String::from_utf8_lossy(&output.stderr)
      )));
    }

    Ok(())
  }

  /// Update git notes
  fn execute_update_notes(&self, notes_ref: &str, commit: &str, note_content: &str) -> RailResult<()> {
    let output = std::process::Command::new("git")
      .current_dir(&self.context.root)
      .args(["notes", "--ref", notes_ref, "add", "-m", note_content, commit])
      .output()
      .with_context(|| format!("Failed to add note to commit {}", commit))?;

    if !output.status.success() {
      return Err(RailError::message(format!(
        "git notes failed: {}",
        String::from_utf8_lossy(&output.stderr)
      )));
    }

    Ok(())
  }

  /// Create a PR branch (branch + commit)
  fn execute_create_pr_branch(&self, name: &str, base: &str, message: &str) -> RailResult<()> {
    // Create branch
    self.execute_create_branch(name, base)?;

    // Checkout branch
    self.execute_checkout(name)?;

    // Create empty commit
    let output = std::process::Command::new("git")
      .current_dir(&self.context.root)
      .args(["commit", "--allow-empty", "-m", message])
      .output()
      .context("Failed to create PR commit")?;

    if !output.status.success() {
      return Err(RailError::message(format!(
        "git commit failed: {}",
        String::from_utf8_lossy(&output.stderr)
      )));
    }

    Ok(())
  }

  /// Execute a split workflow
  /// This delegates to the battle-tested Splitter implementation
  fn execute_split(
    &self,
    crate_name: &str,
    crate_paths: &[String],
    mode: &str,
    target_repo_path: &str,
    branch: &str,
    remote_url: &Option<String>,
  ) -> RailResult<()> {
    // Parse mode
    let split_mode = match mode {
      "single" | "Single" => SplitMode::Single,
      "combined" | "Combined" => SplitMode::Combined,
      _ => return Err(RailError::message(format!("Invalid split mode: {}", mode))),
    };

    // Convert string paths to PathBuf
    let crate_paths: Vec<PathBuf> = crate_paths.iter().map(PathBuf::from).collect();

    // Get security config from context
    let security_config = self
      .context
      .config
      .as_ref()
      .map(|c| c.security.clone())
      .unwrap_or_default();

    // Create splitter
    let splitter = Splitter::new(self.context.root.clone(), security_config)?;

    // Build split config
    let split_config = SplitConfig {
      crate_name: crate_name.to_string(),
      crate_paths,
      mode: split_mode,
      target_repo_path: PathBuf::from(target_repo_path),
      branch: branch.to_string(),
      remote_url: remote_url.clone(),
    };

    // Execute the split
    splitter.split(&split_config)?;

    Ok(())
  }

  /// Execute a sync workflow
  /// This delegates to the battle-tested SyncEngine implementation
  #[allow(clippy::too_many_arguments)]
  fn execute_sync(
    &self,
    crate_name: &str,
    crate_paths: &[String],
    mode: &str,
    target_repo_path: &str,
    branch: &str,
    remote_url: &str,
    direction: &str,
    conflict_strategy: &str,
  ) -> RailResult<()> {
    // Parse mode
    let split_mode = match mode {
      "single" | "Single" => SplitMode::Single,
      "combined" | "Combined" => SplitMode::Combined,
      _ => return Err(RailError::message(format!("Invalid split mode: {}", mode))),
    };

    // Parse direction
    let sync_direction = match direction {
      "to_remote" | "MonoToRemote" => SyncDirection::MonoToRemote,
      "from_remote" | "RemoteToMono" => SyncDirection::RemoteToMono,
      "bidirectional" | "Both" => SyncDirection::Both,
      _ => return Err(RailError::message(format!("Invalid sync direction: {}", direction))),
    };

    // Parse conflict strategy
    let strategy = ConflictStrategy::from_str(conflict_strategy)?;

    // Convert string paths to PathBuf
    let crate_paths: Vec<PathBuf> = crate_paths.iter().map(PathBuf::from).collect();

    // Get security config from context
    let security_config = self
      .context
      .config
      .as_ref()
      .map(|c| Arc::new(c.security.clone()))
      .unwrap_or_else(|| Arc::new(SecurityConfig::default()));

    // Build sync config
    let sync_config = SyncConfig {
      crate_name: crate_name.to_string(),
      crate_paths,
      mode: split_mode,
      target_repo_path: PathBuf::from(target_repo_path),
      branch: branch.to_string(),
      remote_url: remote_url.to_string(),
    };

    // Create sync engine
    let mut sync_engine = SyncEngine::new(self.context.root.clone(), sync_config, security_config, strategy)?;

    // Execute the sync based on direction
    match sync_direction {
      SyncDirection::MonoToRemote => {
        sync_engine.sync_to_remote()?;
      }
      SyncDirection::RemoteToMono => {
        sync_engine.sync_from_remote()?;
      }
      SyncDirection::Both => {
        sync_engine.sync_bidirectional()?;
      }
      SyncDirection::None => {
        // Nothing to do
      }
    }

    Ok(())
  }
}

/// Recursively copy a directory
fn copy_dir_recursive(from: &Path, to: &Path) -> RailResult<()> {
  fs::create_dir_all(to).with_context(|| format!("Failed to create directory: {}", to.display()))?;

  for entry in fs::read_dir(from).with_context(|| format!("Failed to read directory: {}", from.display()))? {
    let entry = entry?;
    let file_type = entry.file_type()?;
    let from_path = entry.path();
    let file_name = entry.file_name();
    let to_path = to.join(&file_name);

    if file_type.is_dir() {
      copy_dir_recursive(&from_path, &to_path)?;
    } else {
      fs::copy(&from_path, &to_path)
        .with_context(|| format!("Failed to copy {} to {}", from_path.display(), to_path.display()))?;
    }
  }

  Ok(())
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_executor_creation() {
    // Just test that we can create the module - actual execution requires real workspace
    // which is tested via integration tests
  }

  #[test]
  fn test_copy_dir_recursive_logic() {
    use tempfile::TempDir;

    let temp_dir = TempDir::new().unwrap();
    let from_dir = temp_dir.path().join("from");
    let to_dir = temp_dir.path().join("to");

    // Create source structure
    fs::create_dir_all(&from_dir).unwrap();
    fs::write(from_dir.join("file1.txt"), "content1").unwrap();
    fs::create_dir_all(from_dir.join("subdir")).unwrap();
    fs::write(from_dir.join("subdir/file2.txt"), "content2").unwrap();

    // Copy
    copy_dir_recursive(&from_dir, &to_dir).unwrap();

    // Verify
    assert!(to_dir.join("file1.txt").exists());
    assert!(to_dir.join("subdir").exists());
    assert!(to_dir.join("subdir/file2.txt").exists());
    assert_eq!(fs::read_to_string(to_dir.join("file1.txt")).unwrap(), "content1");
    assert_eq!(fs::read_to_string(to_dir.join("subdir/file2.txt")).unwrap(), "content2");
  }
}
